# Java基础-数据类型和运算符
<note>
Java 语言支持的类型分为两类：基本数据类型（Primitive Type）和引用类型（Reference Type）。
</note>
## 基本数据类型

### 数值类型

#### 整数类型

##### byte

一个 `byte` 类型在内存中占 8 位（1字节）范围`-128(-2^7) ~ 127(2^7 -1)`

##### short 


一个 `short` 类型在内存中占 16 位（2字节）范围`-32768(-2^15) ~ 32767(2^15-1)`

##### int 

一个 `int` 类型在内存占 32 位（4字节）范围`-2147483648(-2^31) ~ 2147483647(2^31-1)`

##### long

一个 `long` 类型在内存中占 64 位（8 字节）范围`-2^63 ~ 2^63-1`

>如果直接将一个较小的整数值（在 `byte` 或者 `short` 类型的范围内）赋给一个 `byte` 或者 `short` 的变量,系统会自动把这个整数值当成 `byte` 或者 `short` 类型来处理.
>如果使用一个巨大的整数值（超出 int 类型的范围）时，Java 不会自动把这个整数值当成 long 类型来处理。如果希望系统把一个整数值当成 long 类型来处理，应在这个整数值后增加 `l` 或者 `L` 做后缀。

#### 浮点类型

Java 的浮点类型有固定的表数范围和字段长度，字段长度和表数范围与机器无关，Java 的浮点类型遵循 IEEE 标准，采用二进制的科学计数法来表示。

##### float

一个 float 类型在内存中占 4 字节，32 位，第 1 位是符号位，接下来的 8 位表示指数，在接下来的 23 位表示位数。

##### double

一个 double 类型在内存中占 8 字节，64 位，第 1 位表示符号位，接下来的 11 位表示指数，在接下来的 52 位表示尾数。

> 因为 Java 浮点数是用二进制的科学计数法来表示浮点数，因此可能不能精确表示一个浮点数。例如把 `5.12345f`赋值给一个 `float` 类型的变量，接着输出这个变量时看到这个变量的值已经发生了改变。 如果需要一个精确的浮点数，可以使用 `BigDecimal` 类。
> 浮点类型默认的是 `double` 如果希望 `Java` 把一个浮点类型值当成 `float` 来处理，应当在这个浮点类型值后面紧跟一个 `f` 或者 `F`。
> Java 还提供了三个特殊的浮点数值：正无穷大，负无穷大和非数，用于表示溢出或者出错。正浮点数除以 0（Java会自动把和浮点数进行运算的整数 0 当成浮点数 0.0 处理）得到正无穷大（Double/Float 类中的 POSITIVE_INFINITY）.使用一个负浮点数除以 0 得到负无穷大（Double/Float 类中的 NEGATIVE_INFINITY）
> 表示。0.0/0.0 将得到一个非数 NaN.
> 所有的正无穷大以及负无穷大都相等，所有的非数都不相等。
> 100_000_000_000数值中的`_`方便阅读。无实际含义。

![Java_data_type.png](Java_data_type.png)



### 字符型

#### char

字符型有三种表示形式

* 直接通过单个字符来指定字符型值，例如`'A'`、`'9'` 和 `'0'` 等.
* 通过转移字符标识特殊字符型值，例如`'\n'`、`'\t'`
* 直接使用 `Unicode` 值来表示字符型值，格式是`'\uXXXX'`，其中 `XXXX` 代表 一个十六进制的整数。

![常用转义字符.png](常用转义字符.png)

字符类型也可以使用十六进制编码方式来表示，范围是`'\u0000'~'\uFFFF'`，一共可以表示 `65535` 个字符，其中前 256 个（`'\u0000'~'\u00FF'`）字符和 ASCII 码中的字符完全重合。
计算机底层保存字符时，实际上保存的是该字符对应的编号，因此 `char` 类型的值可以直接作为整形使用，它相当于一个 16 位的无符号整数，表数范围是 `0~65535`.
如果把 0~65535 范围内的一个 `int` 整数赋给 `char` 类型变量，系统自动会把这个 `int` 整数当成 `char` 类型来处理

### 布尔类型

#### boolean

用于表示逻辑上的`真`或`假`, `boolean`类型的数值只能是 `true` 或者 `false`, 不能用 `0` 或者`非0` 来表示，其他基本数据类型也不能转换成 `boolean` 类型。

> Java 规范没有强制指定 boolean 类型的变量所占用的内存空间。由于大部分计算机在内存分配时允许的最小内存单元是字节（8 位），因此 bit 大部分时候实际占用 8 位。
> Java虚拟机规范一书提到 :
>
> * 在Java虚拟机中没有任何供 boolean值专用的字节码指令,Java语言表达式所操作的
>   boolean值,在编译之后都使用Java虚拟机中的int数据类型来代替。
> * Java虚拟机直接支持 boolean类型的数组,虚拟机的 navarra指令参见第6章的newarray小节可以创建这种数组。boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令。
>   因为在虚拟机规范中说了，boolean值在编译之后都使用Java虚拟机中的int数据类型来代替，而int是4个字节，那么boolean值就是4个字节。
> * boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令，因为两者共用，只有两者字节一样才能通用呀，所以byte数组中一个byte是1个字节，那么boolean数组中boolean是1个字节。
>
> 总结：boolean在数组情况下为1个字节，单个boolean为4个字节。

### 基本数据类型的转换

Java 所有的数值类型可以相互转换,如果系统支持把某种基本类型的值直接赋给另一种基本类型的变量,则这种方式被称为自动类型转换.当把一个表述范围小的数值或者变量直接赋给另一个表数范围大的变量时,系统可以进行自动类型转换.否则就需要强制转换.

#### 自动类型转换

表数范围小的数值赋给表数范围的变量.
Java 支持自动类型转换图:

![Java自动类型转换图](Java自动类型转换.png)

除了基本类型的自动转换外,把任何基本类型的值和字符串进行连接运算时,基本类型的值将自动转为字符串类型(ps:将基本类型转化为字符串类型时,可以把基本类型的值与空字符串相加).

#### 强制类型转换

如果想把上图箭头右边的数据类型转换为左边的类型,则必须进行强制类型转换.强转的格式为`(TargetType)value`强制类型转换的运算符是圆括号.
需要注意强制类型转换会造成数据溢出,从而导致数据丢失.

#### 表达式类型的自动提升

当一个算术表达式中包含多个基本类型的值时, 整个算术表达式的数据类型将发生自动提升.
Java 自动提升规则:

* 所有的 byte 类型,short 类型和 char 类型将被提升到 int 类型.
* 整个算术表达式的数据类型自动提升到与表达式中最高等级操作同样的类型.操作数的等级如上如所示,箭头右边的等级高于箭头左边类型的等级.

## 引用数据类型

* 类 
* 接口 
* 数组

## 运算符

### 算术运算符

* `+`: 加法运算符（还可以作为字符串的连接运算符）
* `-`: 减法运算符
* `*`: 乘法运算符
* `/`: 除法运算符
  如果除法运算的两个操作数都是整数类型，则计算结果也是整数，就是将自然除法的结果截取取整。如果除法运算两个操作数都是整数类型，则除数不可以是 0，否则将引发除以 0 异常。如果一个或两个操作数是浮点数，则计算结果也是浮点数，这个结果就是自然除法的结果，而且此时允许除数是 0 或者 0.0，得到的结果是正无穷大挥着负无穷大。
* `%`: 求余运算符
* `++`: 自加。
  1. 自加是单目运算符，只能操作一个数。
  2. 自加运算符只能操作单个数值型（整形、浮点型）变量，不能操作常量或表达式。
  3. 如果 ++ 放在左边，则先把操作数加 1，然后才把操作数放入表达式中运算。如果 ++ 放在右边，则先把操作数放入表达式中运算，然后才把操作数加 1
* `--`: 自减。单目运算符。与`++` 类似，只是将操作数 -1

### 位运算符

* `&`: 按位与。当两位同时为 1 时才返回 1.
* `|`: 按位或。只要有一位为 1 即可返回 1。
* `~`: 按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。
* `^`: 按位异或。当两位相同时返回0，不同时返回 1。
* `<<`: 左移运算符。
* `>>`: 右移运算符.
* `>>>`: 无符号右移运算符.

![位运算符运算法则](位运算符运算法则.png)


### 逻辑运算符

* `&&`: 与,前后两个操作数必须都是 `true` 才返回 `true`,否则饭后 `false`.
* `&`: 不短路与,与 `&&`作用相同,但不会短路.
* `||`:或,只要两个操作数一个为`true`,则返回 `true`,否则返回 `false`
* `|`: 不短路或, 作用与 `||`相同,但不会短路.
* `!`: 非. 取反
* `^`: 异或. 当两个操作数不同时返回 `true`,相同时返回 `false`

### 三目运算符

* `?:` 三目运算符只有一个,语法格式为`(expression) ? if-true-statement : if-false-statement`

>注意：
>自加和自减只能用于惭怍变量，不能用于操作数值直接量、常量或表达式。

### 赋值运算符

* `=` 

#### 扩展后的赋值运算符

* `+=`: 对于 `x+=y`,即对应于 `x = x + y`
* `-=`: 对于 `x-=y`,即对应于 `x = x - y`
* `*=`: 对于 `x*=y`,即对应于 `x = x * y`
* `/=`: 对于 `x/=y`,即对应于 `x = x / y`
* `%=`: 对于 `x%=y`,即对应于 `x = x % y`
* `|=`: 对于 `x|=y`,即对应于 `x = x | y`
* `^=`: 对于 `x^=y`,即对应于 `x = x ^ y`
* `<<=`: 对于 `x<<=y`,即对应于 `x = x << y`
* `>>=`: 对于 `x>>=y`,即对应于 `x = x >> y`
* `>>>=`: 对于 `x>>>=y`,即对应于 `x = x >>> y`

### 比较运算符

* `>`: 大于,只支持左右两边操作数是数值类型.
* `>=`: 大于等于,只支持左右两边操作数是数值类型.
* `<`: 小于,只支持左右两边操作数是数值类型.
* `<=`: 小于等于,只支持左右两边操作数是数值类型.
* `==`: 等于,如果比较的两个操作数都是数值类型,即使两个操作数的类型不同,只要他们值相等,也返回`true`. 如果两个操作数都是引用类型,那么比较的是两个操作数的引用地址.
* `!=`: 不等于.数据类型比较,无关类型,只进行值比较.引用类型比较对象的引用地址.

### 运算符的优先级

![运算符优先级.png](运算符优先级.png)


* 不要把一个表达式写的过于复杂,如果一个表达式复杂,则应该拆成几步来执行
* 不要过多的依赖运算符的优先级来控制表达式的执行顺序,尽量用 `()` 来控制