---
title: 设计模式 - 抽象工厂 

cover: false
toc: true
mathjax: false
date: 2020-08-03 00:59:19
password:
summary: 所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。抽象工厂设计模式包含 抽象工厂、具体工厂、抽象产品、具体产品等四个角色
tags: 设计模式
categories: 设计模式
sort: 5
url: 164885722
---

在讲解抽象工厂前我们首先需要了解两个概念：

* **产品等级结构：产品的等级结构即产品的继承结构**。如果一个抽象类是电视机，其子类有海尔电视机、海信电视机、创维电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

* **产品族：**在抽象工厂模式中，**产品族是指由一个工厂生产的，位于不同产品等级结构中的一组产品**，如海尔电器生产的海尔电视机、海尔冰箱，海尔电视机位于电视机产品等级结构中，海尔冰箱位于冰箱产品等级结构中。海尔电视机，海尔冰箱构成了一个产品族。
  ![产品结构&产品族](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145330379.png)

图中一共有四个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。

引进抽象工厂模式

所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。如果用图来描述的话，如下图：
![抽象工厂](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145338510.png)

## 定义

**抽象工厂模式**（**Abstract Factory**），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。

## 结构

![抽象工厂](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145347138.png)

抽象工厂包含如下角色：

* **IFactory：抽象工厂**
  抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品。
* **ConCreteFactory：具体工厂**
  具体工厂实现生成不同的具体产品家族，要创建一个产品，客户端主要使用其中一个工厂而不需要实例化任何产品对象。
* **IProduct：抽象产品**
  不同的抽象产品为不同的产品家族，每一个具体的工厂都能实现一整套的产品
* **ConcreteProduct：具体产品**
  对抽象产品的具体分类的实现

## 场景示例

说起抽象工厂不得不让人想起位于各大城市中鱼龙混杂的电子城。只有你想不到的，没有他们生产不出来的。 500块的Iphone你买到过吗？你见到过装有安卓系统、小米摄像头的苹果手机吗？下面让我们一起来见识一下装有安卓手机系统的苹果手机是怎么在电子城生产出来的。
手机卖家，也就是我们的手机工厂，使用主板、摄像头、手机外壳就能组装出一台手机：

```java
public interface IFactory {
    MainBoard createMainBoard();

    CameraLens createCameraLens();

    Case createCase();

}
```

然后无良卖家根据组装流程给组装了三种类型的手机

```java
/**
 * 苹果手机
 */
public class AppleFactory implements IFactory {
    @Override
    public MainBoard createMainBoard() {
        return new IosMainBoard();
    }

    @Override
    public CameraLens createCameraLens() {
        return new IosCameraLens();
    }

    @Override
    public Case createCase() {
        return new IosCase();
    }
}

/**
 * 组装Android手机
 */
public class AndroidFactory implements IFactory {
    @Override
    public MainBoard createMainBoard() {
        return new AndroidMainBoard();
    }

    @Override
    public CameraLens createCameraLens() {
        return new AndroidCameraLens();
    }

    @Override
    public Case createCase() {
        return new AndroidCase();
    }
}

/**
 * 组装装有安卓操作系统、安卓摄像头的苹果手机
 */
public class AndroidAppleFactory implements IFactory {
    @Override
    public MainBoard createMainBoard() {
        return new AndroidMainBoard();
    }

    @Override
    public CameraLens createCameraLens() {
        return new AndroidCameraLens();
    }

    @Override
    public Case createCase() {
        return new IosCase();
    }
}
```

不同的配件产品

```java
public class AndroidCameraLens implements CameraLens {
    @Override
    public String getCameraLens() {
        return "安卓摄像头";
    }
}

public class AndroidCase implements Case {
    @Override
    public String getCase() {
        return "安卓手机外壳";
    }
}

public class AndroidMainBoard implements MainBoard {
    @Override
    public String getMainBoard() {
        return "安卓主板";
    }
}

public class IosCameraLens implements CameraLens {
    @Override
    public String getCameraLens() {
        return "苹果摄像头";
    }
}

public class IosCase implements Case {
    @Override
    public String getCase() {
        return "苹果手机外壳";
    }
}

public class IosMainBoard implements MainBoard {
    @Override
    public String getMainBoard() {
        return "苹果手机主板";
    }
}
```

然后顾客来买手机

```java
public class App {
    public static void main(String[] args) {
        IFactory factory = new AppleFactory();
        String mainBoard = factory.createMainBoard().getMainBoard();
        String cameraLens = factory.createCameraLens().getCameraLens();
        String aCase = factory.createCase().getCase();
        System.out.println(String.format("手机配件：%s、%s、%s，售价：12888", mainBoard, cameraLens, aCase));
    }
}
```

骚年，新出的Apple XRS `手机配件：装有苹果主板、苹果摄像头、苹果手机外壳，售价：12888`，要不要来一台？
嫌贵啊，没关系，我这有新出的安卓机：

```java
public class App {
    public static void main(String[] args) {
        IFactory factory = new AndroidFactory();
        String mainBoard = factory.createMainBoard().getMainBoard();
        String cameraLens = factory.createCameraLens().getCameraLens();
        String aCase = factory.createCase().getCase();
        System.out.println(String.format("手机配件：%s、%s、%s，售价：4000", mainBoard, cameraLens, aCase));
    }
}
```

`手机配件：装有安卓主板、安卓摄像头、安卓手机外壳，售价：4000`，超高性价比，只要4000，考不考虑入手？
这样吧，骚年，你我相遇也是有缘，我这新弄了一台二手Apple，便宜出你，你看怎么样

```java
public class App {
    public static void main(String[] args) {
        IFactory factory = new AndroidAppleFactory();
        String mainBoard = factory.createMainBoard().getMainBoard();
        String cameraLens = factory.createCameraLens().getCameraLens();
        String aCase = factory.createCase().getCase();
        System.out.println(String.format("手机配件：%s、%s、%s，售价：4000", mainBoard, cameraLens, aCase));
    }
}
```

`手机配件：安卓主板、安卓摄像头、苹果手机外壳，售价：500` 只要500，95成新，怎么样。

**勿占小便宜啊！！**

## 优点

* 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。**所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为**。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。

* **当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象**。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。

* 增加新的具体工厂和产品族很方便，无须修改已有系统，符合`开闭原则`。

## 缺点

* 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

* **开闭原则的倾斜性**（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

## 应用场景

* **当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。** 
* 系统中有多于一个的产品族，而每次只使用其中某一产品族。
* 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
* 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

简单来讲，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。

> **“开闭原则”的倾斜性**
>
> * **“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的**。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：
>   1. 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。
>
>   2. 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。
>
> * 抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。
>
> **工厂模式的退化**
>
> * 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。

## 总结

* 产品等级结构即产品的继承结构关系。产品族即由一个共产生产的，位于不同产品等级结构中的一组产品。

* 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

* 抽象工厂包含四个角色：抽象工厂、具体工厂、抽象产品、具体产品。

* 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。抽象工厂中利用工厂方法实现生产方法是很普遍的做法。
* 抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。
* 抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。




